[ { "title": "集合", "url": "/posts/JavaSE_%E9%9B%86%E5%90%88/", "categories": "集合", "tags": "后端", "date": "2022-09-11 06:34:00 +0000", "snippet": "1.Collection集合1.1数组和集合的对比【记忆】 相同点 都是容器,可以存储多个数据 不同点 数组的长度是不可变的,集合的长度是可变的 数组可以存基本数据类型和引用数据类型 集合只能存引用数据类型,如果要存基本数据类型,需要存对应的包装类 1.2集合类体系结构" }, { "title": "面向对象-包数递时", "url": "/posts/JavaSE_advanced6/", "categories": "面向对象-知识点4", "tags": "后端", "date": "2022-09-02 06:34:00 +0000", "snippet": "面向对象-包数递时1.包装类1.1 基本类型包装类 基本类型包装类的作用 将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据 常用的操作之一：用于基本数据类型与字符串之间的转换 基本类型对应的包装类 基本数据类型 包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 1.2 Integer类 Integer类概述 包装一个对象中的原始类型 int 的值 Integer类构造方法 方法名 说明 public Integer(int value) 根据 int 值创建 Integer 对象(过时) public Integer(String s) 根据 String 值创建 Integer 对象(过时) public static Integer valueOf(int i) 返回表示指定的 int 值的 Integer 实例 public static Integer valueOf(String s) 返回一个保存指定值的 Integer 对象 String 示例代码 public class IntegerDemo { public static void main(String[] args) { //public Integer(int value)：根据 int 值创建 Integer 对象(过时) Integer i1 = new Integer(100); System.out.println(i1); //public Integer(String s)：根据 String 值创建 Integer 对象(过时) Integer i2 = new Integer(\"100\");// Integer i2 = new Integer(\"abc\"); //NumberFormatException System.out.println(i2); System.out.println(\"--------\"); //public static Integer valueOf(int i)：返回表示指定的 int 值的 Integer 实例 Integer i3 = Integer.valueOf(100); System.out.println(i3); //public static Integer valueOf(String s)：返回一个保存指定值的Integer对象 String Integer i4 = Integer.valueOf(\"100\"); System.out.println(i4); }} 1.3 自动拆箱和自动装箱 自动装箱 ​\t把基本数据类型转换为对应的包装类类型 自动拆箱 ​\t把包装类类型转换为对应的基本数据类型 示例代码 Integer i = 100; // 自动装箱i += 200; // i = i + 200; i + 200 自动拆箱；i = i + 200; 是自动装箱 1.4 int和String类型的相互转换 int转换为String 转换方式 方式一：直接在数字后加一个空字符串 方式二：通过String类静态方法valueOf() 示例代码 public class IntegerDemo { public static void main(String[] args) { //int --- String int number = 100; //方式1 String s1 = number + \"\"; System.out.println(s1); //方式2 //public static String valueOf(int i) String s2 = String.valueOf(number); System.out.println(s2); System.out.println(\"--------\"); }} String转换为int 转换方式 方式一：先将字符串数字转成Integer，再调用valueOf()方法 方式二：通过Integer静态方法parseInt()进行转换 示例代码 public class IntegerDemo { public static void main(String[] args) { //String --- int String s = \"100\"; //方式1：String --- Integer --- int Integer i = Integer.valueOf(s); //public int intValue() int x = i.intValue(); System.out.println(x); //方式2 //public static int parseInt(String s) int y = Integer.parseInt(s); System.out.println(y); }} 2.数组的高级操作2.1 二分查找 二分查找概述 查找指定元素在数组中的位置时,以前的方式是通过遍历,逐个获取每个元素,看是否是要查找的元素,这种方式当数组元素较多时,查找的效率很低 二分查找也叫折半查找,每次可以去掉一半的查找范围,从而提高查找的效率 需求 在数组{1,2,3,4,5,6,7,8,9,10}中,查找某个元素的位置 实现步骤 定义两个变量，表示要查找的范围。默认min = 0 ，max = 最大索引 循环查找，但是min &lt;= max 计算出mid的值 判断mid位置的元素是否为要查找的元素，如果是直接返回对应索引 如果要查找的值在mid的左半边，那么min值不变，max = mid -1.继续下次循环查找 如果要查找的值在mid的右半边，那么max值不变，min = mid + 1.继续下次循环查找 当min &gt; max 时，表示要查找的元素在数组中不存在，返回-1. 代码实现 public class MyBinarySearchDemo { public static void main(String[] args) { int [] arr = {1,2,3,4,5,6,7,8,9,10}; int number = 11; //1,我现在要干嘛? --- 二分查找 //2.我干这件事情需要什么? --- 数组 元素 //3,我干完了,要不要把结果返回调用者 --- 把索引返回给调用者 int index = binarySearchForIndex(arr,number); System.out.println(index); } private static int binarySearchForIndex(int[] arr, int number) { //1,定义查找的范围 int min = 0; int max = arr.length - 1; //2.循环查找 min &lt;= max while(min &lt;= max){ //3.计算出中间位置 mid int mid = (min + max) &gt;&gt; 1; //mid指向的元素 &gt; number if(arr[mid] &gt; number){ //表示要查找的元素在左边. max = mid -1; }else if(arr[mid] &lt; number){ //mid指向的元素 &lt; number //表示要查找的元素在右边. min = mid + 1; }else{ //mid指向的元素 == number return mid; } } //如果min大于了max就表示元素不存在,返回-1. return -1; } } 注意事项 有一个前提条件，数组内的元素一定要按照大小顺序排列，如果没有大小顺序，是不能使用二分查找法的 2.2 冒泡排序 冒泡排序概述 一种排序的方式，对要进行排序的数据中相邻的数据进行两两比较，将较大的数据放在后面，依次对所有的数据进行操作，直至所有数据按要求完成排序 如果有n个数据进行排序，总共需要比较n-1次 每一次比较完毕，下一次的比较就会少一个数据参与 代码实现 public class MyBubbleSortDemo2 { public static void main(String[] args) { int[] arr = {3, 5, 2, 1, 4}; //1 2 3 4 5 bubbleSort(arr); } private static void bubbleSort(int[] arr) { //外层循环控制的是次数 比数组的长度少一次. for (int i = 0; i &lt; arr.length -1; i++) { //内存循环就是实际循环比较的 //-1 是为了让数组不要越界 //-i 每一轮结束之后,我们就会少比一个数字. for (int j = 0; j &lt; arr.length - 1 - i; j++) { if (arr[j] &gt; arr[j + 1]) { int temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } } } printArr(arr); } private static void printArr(int[] arr) { for (int i = 0; i &lt; arr.length; i++) { System.out.print(arr[i] + \" \"); } System.out.println(); } } 3.递归3.1 递归 递归的介绍 以编程的角度来看，递归指的是方法定义中调用方法本身的现象 把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解 递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算 递归的基本使用 public class MyFactorialDemo2 { public static void main(String[] args) { int sum = getSum(100); System.out.println(sum); } private static int getSum(int i) { //1- 100之间的和 //100 + (1-99之间的和) // 99 + (1- 98之间的和) //.... //1 //方法的作用: 求 1- i 之间和 if(i == 1){ return 1; }else{ return i + getSum(i -1); } }} 注意事项 递归一定要有出口。否则内存溢出 递归虽然有出口，但是递归的次数也不宜过多。否则内存溢出 3.2 递归求阶乘 案例需求 ​\t用递归求5的阶乘，并把结果在控制台输出 代码实现 public class DiGuiDemo01 { public static void main(String[] args) { //调用方法 int result = jc(5); //输出结果 System.out.println(\"5的阶乘是：\" + result); } //定义一个方法，用于递归求阶乘，参数为一个int类型的变量 public static int jc(int n) { //在方法内部判断该变量的值是否是1 if(n == 1) { //是：返回1 return 1; } else { //不是：返回n*(n-1)! return n*jc(n-1); } }} 内存图 ![08递归内存图](/assets/blog_res/2022-09-02-JavaSE_advanced6.assets/08.png) ##3.3 Arrays Arrays的常用方法 方法名 说明 public static String toString(int[] a) 返回指定数组的内容的字符串表示形式 public static void sort(int[] a) 按照数字顺序排列指定的数组 public static int binarySearch(int[] a, int key) 利用二分查找返回指定元素的索引 示例代码 public class MyArraysDemo { public static void main(String[] args) { // public static String toString(int[] a) 返回指定数组的内容的字符串表示形式 // int [] arr = {3,2,4,6,7}; // System.out.println(Arrays.toString(arr)); // public static void sort(int[] a)\t 按照数字顺序排列指定的数组 // int [] arr = {3,2,4,6,7}; // Arrays.sort(arr); // System.out.println(Arrays.toString(arr)); // public static int binarySearch(int[] a, int key) 利用二分查找返回指定元素的索引 int [] arr = {1,2,3,4,5,6,7,8,9,10}; int index = Arrays.binarySearch(arr, 0); System.out.println(index); //1,数组必须有序 //2.如果要查找的元素存在,那么返回的是这个元素实际的索引 //3.如果要查找的元素不存在,那么返回的是 (-插入点-1) //插入点:如果这个元素在数组中,他应该在哪个索引上. } } 工具类设计思想 构造方法用 private 修饰 成员用 public static 修饰 4.时间日期类4.1 时间概述 北京时间需要在世界标准时间加上8小时 计算机中时间原点（UNIX操作系统,C语言的诞生日） ​ 1970年1月1日 00:00:003.时间换算单位​ 1秒 = 1000毫秒4.2 时间日期类-Date构造方法 什么是Date类 Date 代表了一个特定的时间，精确到毫秒 2.Date类构造方法 方法名 说明 public Date() 创建 Date对象，默认存储当前时间，单位毫秒 public Date(long date) 创建 Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数 示例代码import java.util.Date;public class DateDemo1 { public static void main(String[] args) {// public Date()\t\t创建一个Date对象，表示默认时间//public Date(long date)\t创建一个Date对象，表示指定时间 //那么这个时间就表示电脑中的当前时间。 Date date1 = new Date(); System.out.println(date1); //从计算机的时间原点开始，过了指定毫秒的那个时间。 Date date2 = new Date(0L); System.out.println(date2);//Thu Jan 01 08:00:00 CST 1970 //从时间原点开始，过了0毫秒。 //因为我们是在中国，我们是在东八区需要+8小时。 //1970年1月1日 上午的10点 Date date3 = new Date(2*3600L * 1000); System.out.println(date3); }}4.3 时间日期类-Date成员方法 常用方法 方法名 说明 public long getTime() 获取的是日期对象从1970年1月1日 00:00:00到现在的毫秒值 public void setTime(long time) 设置时间，给的是毫秒值 示例代码 public class DateDemo2 { public static void main(String[] args) {// public long getTime()\t\t\t获取时间对象的毫秒值// public void setTime(long time)\t\t设置时间，传递毫秒值 //method1(); //method2(); } private static void method2() { Date date1 = new Date(); date1.setTime(0L); System.out.println(date1); } private static void method1() { //把当前时间封装成一个date对象 Date date1 = new Date(); //获取这个date对象的毫秒值 --- 获取当前时间的毫秒值 long time = date1.getTime(); System.out.println(time); \t\t long time2 = System.currentTimeMillis(); System.out.println(time2); }} 4.4 SimpleDateFormat类1.SimpleDateFormat类有什么作用？​\tSimpleDateFormat可以对Date对象和日期字符串,进行格式化和解析2.如何使用？1.常用的模式字母及应对关系如下:HH：24小制,hh:12小时制2.SimpleDateFormat类构造方法 方法名 说明 public SimpleDateFormat() 构造一个SimpleDateFormat，使用默认模式和日期格式 public SimpleDateFormat(String pattern) 构造一个SimpleDateFormat使用给定的模式 3.SimpleDateFormat类的常用方法 格式化(从Date到String)​\t\tpublic final String format(Date date)：将日期格式化成日期/时间字符串 解析(从日期/时间字符串String到Date)​\t\tpublic Date parse(String source)：从给定字符串的开始解析文本以生成日期示例代码（公历日期标准格式为；2007年2月6日；或：2007-02-06）public class DateDemo4 { public static void main(String[] args) throws ParseException { String s = \"2048-01-01\"; //SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日 HH:mm:ss\"); SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\"); Date date = sdf.parse(s); System.out.println(date); }}小结 北京时间需要在世界标准时间加上8小时 计算机中时间原点​ 1970年1月1日 00:00:003.时间换算单位​ 1秒 = 1000毫秒4.Date类概述​ Date 代表了一个特定的时间，精确到毫秒5.如何创建时间对象?​ 通过Date的构造方法，空参构造和带参构造，带参构造参数：是自1970年7月1日00:00:00经过的毫秒数6.如何格式化和解析日期通过SimpleDateFormat，创建SimpleDateFormat类:new SimpleDateFormat(“日期模式”)格式化:format(Date string)解析: parse(String date)" }, { "title": "面向对象-异常", "url": "/posts/JavaSE_advanced5/", "categories": "面向对象-知识点3", "tags": "后端", "date": "2022-09-02 06:34:00 +0000", "snippet": "面向对象-知识点34.异常4.1 异常的体系结构和分类1.什么是异常？异常就是程序出现了不正常的情况注意：语法错误不算在异常体系中2.异常的体系结构//除RuntimeException之外的异常public class ExceptionDemo1 { public static void main(String[] args) {// int [] arr = {1,2,3,4,5};// System.out.println(arr[10]);//ArrayIndexOutOfBoundsException// String s = null;// System.out.println(s.equals(\"嘿嘿\"));//NullPointerException SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日\"); sdf.parse(\"2048-1月1日\");//ParseException }}3.编译时异常和运行时异常的区别 编译时异常 都是Exception类及其子类 必须显式处理(手动处理)，否则程序就会发生错误，无法通过编译 运行时异常 都是RuntimeException类及其子类 无需显式处理(手动处理)，也可以和编译时异常一样处理 图示 4.2 JVM默认处理异常的方式1.如果程序出现了问题，我们没有做任何处理，最终JVM 会做默认的处理，处理方式有如下两个步骤： 把异常的名称，错误原因及异常出现的位置等信息输出在了控制台 程序停止执行 public class ExceptionDemo2 { public static void main(String[] args){ //思考:控制台为什么会有这样的红色字体呢? 是谁打印的? int [] arr = {1,2,3,4,5}; System.out.println(arr[10]);//当代码出现了异常,那么就在这里创建了一个异常对象. //new ArrayIndexOutOfBoundsException(); //首先会看,程序中有没有自己处理异常的代码. //如果没有,交给本方法的调用者处理. //最终这个异常会交给虚拟机默认处理. //JVM默认处理异常做了哪几件事情: //1,将异常信息以红色字体展示在控制台上. //2,停止程序运行. --- 哪里出现了异常,那么程序就在哪里停止,下面的代码不执行了. System.out.println(\"嘿嘿嘿,我最帅\"); }}4.3throws方式处理异常1.定义格式 声明异常-&gt;说明一下有异常public void 方法() throws 异常类名 { }示例代码public class ExceptionDemo6 { public static void main(String[] args) throws ParseException { method1(); //此时调用者也没有处理.还是会交给虚拟机处理. method2(); //还是继续交给调用者处理.而main方法的调用者是虚拟机还是会采取虚拟机默认处理异常的方法. } //告诉调用者,你调用我,有可能会出现这样的异常哦. //如果方法中没有出现异常,那么正常执行 //如果方法中真的出现了异常,其实也是将这个异常交给了调用者处理. private static void method1() /*throws NullPointerException*/ { int [] arr = null; for (int i = 0; i &lt; arr.length; i++) {//出现的空指针异常,还是由虚拟机创建出来的. System.out.println(arr[i]); } } //告诉调用者,你调用我,有可能会出现这样的异常哦. //如果方法中没有出现异常,那么正常执行 //如果方法中真的出现了异常,其实也是将这个异常交给了调用者处理. private static void method2() throws ParseException { SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日\"); sdf.parse(\"2048-10月10日\"); }}4.4 throws方式处理异常-注意事项简单来说:编译时的异常，必须声明，谁调用谁处理，最后让jvm来处理，运行时异常可以不声明import java.text.ParseException;import java.text.SimpleDateFormat;public class ExceptionDemo6 { public static void main(String[] args) throws ParseException { method1(); //此时调用者也没有处理.还是会交给虚拟机处理. method2(); //还是继续交给调用者处理.而main方法的调用者是虚拟机还是会采取虚拟机默认处理异常的方法. } //告诉调用者,你调用我,有可能会出现这样的异常哦. //如果方法中没有出现异常,那么正常执行 //如果方法中真的出现了异常,其实也是将这个异常交给了调用者处理. //如果声明的异常是一个运行时异常,那么声明的代码可以省略 private static void method1() /*throws NullPointerException*/ { int [] arr = null; for (int i = 0; i &lt; arr.length; i++) {//出现的空指针异常,还是由虚拟机创建出来的. System.out.println(arr[i]); } } //告诉调用者,你调用我,有可能会出现这样的异常哦. //如果方法中没有出现异常,那么正常执行 //如果方法中真的出现了异常,其实也是将这个异常交给了调用者处理. //如果声明的异常是一个编译时异常,那么声明的代码必须要手动写出. private static void method2() throws ParseException { SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy年MM月dd日\"); sdf.parse(\"2048-10月10日\"); }}4.5 throw抛出异常1.格式​\tthrow new 异常();2.注意​\t这个格式是在方法内的，表示当前代码手动抛出一个异常，下面的代码无法再执行了3.抛出处理异常的意义1.在方法中,当传递的参数有误时,没有继续运行的必要了，采取抛出处理,表示该方法结束 告诉调用者方法中出现了问题4.throws和throw的区别 throws throw 用在方法声明后面，跟的是异常类名 用在方法体内，跟的是异常对象名 表示声明异常，调用该方法有可能会出现这样的异常 表示手动抛出异常对象(百分百抛出异常) 可以声明多个异常 只能有一个 示例代码public class ExceptionDemo7 { public static void main(String[] args) { System.out.println(\"家里有一个貌美如花的老婆\"); System.out.println(\"还有一个当官的兄弟\"); System.out.println(\"自己还有一个买卖\"); System.out.println(\"这样的生活你要不要?\"); throw new RuntimeException(); //当代码执行到这里,就创建一个异常对象 //该异常创建之后,暂时没有手动处理.抛给了调用者处理 //下面的代码不会再执行了. //System.out.println(\"武大郎的标准生活\"); }} public class ExceptionDemo8 { public static void main(String[] args) { //int [] arr = {1,2,3,4,5}; int [] arr = null; printArr(arr);//就会 接收到一个异常. //我们还需要自己处理一下异常. } private static void printArr(int[] arr) { if(arr == null){ //调用者知道成功打印了吗? //System.out.println(\"参数不能为null\"); throw new NullPointerException(); //当参数为null的时候 //手动创建了一个异常对象,抛给了调用者. }else{ for (int i = 0; i &lt; arr.length; i++) { System.out.println(arr[i]); } } }}4.6 try-catch自己处理异常 定义格式 try {\t可能出现异常的代码;} catch(异常类名 变量名) {\t异常的处理代码;} 执行流程 程序从 try 里面的代码开始执行 出现异常，就会跳转到对应的 catch 里面去执行 执行完毕之后，程序还可以继续往下执行 示例代码 public class ExceptionDemo9 { public static void main(String[] args) { //好处:为了能让代码继续往下运行. int [] arr = null; try{ //有肯能发现异常的代码 printArr(arr); }catch (NullPointerException e){ //如果出现了这样的异常,那么我们进行的操作 System.out.println(\"参数不能为null\"); } System.out.println(\"嘿嘿嘿,我最帅!!!\"); } private static void printArr(int[] arr) { if(arr == null){ throw new NullPointerException(); }else{ for (int i = 0; i &lt; arr.length; i++) { System.out.println(arr[i]); } } }} 4.7 try-catch常见问题 如果 try 中没有遇到问题，怎么执行？ 会把try中所有的代码全部执行完毕,不会执行catch里面的代码 如果 try 中遇到了问题，那么 try 下面的代码还会执行吗？ 那么直接跳转到对应的catch语句中,try下面的代码就不会再执行了当catch里面的语句全部执行完毕,表示整个体系全部执行完全,继续执行下面的代码 如果出现的问题没有被捕获，那么程序如何运行？ 那么try…catch就相当于没有写.那么也就是自己没有处理.默认交给虚拟机处理. 同时有可能出现多个异常怎么处理？ 出现多个异常,那么就写多个catch就可以了.注意点:如果多个异常之间存在子父类关系.那么父类一定要写在下面 public class ExceptionDemo10 { public static void main(String[] args) { //1.如果 try 中没有遇到问题，怎么执行？ --- 会把try中所有的代码全部执行完毕,不会执行catch里面的代码 //2.如果 try 中遇到了问题，那么 try 下面的代码还会执行吗？ //那么直接跳转到对应的catch语句中,try下面的代码就不会再执行了 //当catch里面的语句全部执行完毕,表示整个体系全部执行完全,继续执行下面的代码 //3.如果出现的问题没有被捕获，那么程序如何运行？ //那么try...catch就相当于没有写.那么也就是自己没有处理. //默认交给虚拟机处理. //4.同时有可能出现多个异常怎么处理？ //出现多个异常,那么就写多个catch就可以了. //注意点:如果多个异常之间存在子父类关系.那么父类一定要写在下面 // method1(); try { Scanner sc = new Scanner(System.in); System.out.println(\"请输入你的年龄\"); String line = sc.nextLine(); int age = Integer.parseInt(line);//格式化异常 System.out.println(age); System.out.println(2 / 0); //数学异常 } catch (Exception e) { //以后我们针对于每种不同的异常,有可能会有不同的处理结果. } System.out.println(\"测试456\");}private static void method1() { try { Scanner sc = new Scanner(System.in); System.out.println(\"请输入你的年龄\"); String line = sc.nextLine(); int age = Integer.parseInt(line);//格式化异常 System.out.println(age); System.out.println(2 / 0); //数学异常 } catch (NumberFormatException e) { System.out.println(\"格式化异常出现了\"); }catch (ArithmeticException e) { System.out.println(\"数学运算异常出现了\"); } System.out.println(\"测试456\");}4.7 Throwable中的常见方法（重点） 常用方法 方法名 说明 public String getMessage() 返回此 throwable 的详细消息字符串 public String toString() 返回此可抛出的简短描述 public void printStackTrace() 把异常的错误信息输出在控制台 示例代码 public class ExceptionDemo11 { //public String getMessage​() 返回此 throwable 的详细消息字符串 //public String toString​() 返回此可抛出的简短描述 //public void printStackTrace​() 把异常的错误信息输出在控制台(字体为红色的) public static void main(String[] args) { try { int [] arr = {1,2,3,4,5}; System.out.println(arr[10]);//虚拟机帮我们创建了一个异常对象 new ArrayIndexOutOfBoundsException(); } catch (ArrayIndexOutOfBoundsException e) { /*String message = e.getMessage(); System.out.println(message);*/ /* String s = e.toString(); System.out.println(s);*/ e.printStackTrace(); } System.out.println(\"嘿嘿嘿\"); }} 4.8 异常的练习 需求 键盘录入学生的姓名和年龄,其中年龄为18 - 25岁,超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止 实现步骤 创建学生对象 键盘录入姓名和年龄，并赋值给学生对象 如果是非法数据就再次录入 代码实现 学生类 package com.itheima.exce; public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { if(age &gt;= 18 &amp;&amp; age &lt;= 25){ this.age = age; }else{ throw new RuntimeException(\"年龄超出了范围\"); } } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; }} package com.itheima.exce; import java.util.Scanner; public class ExceptionDemo12 { public static void main(String[] args) { // 键盘录入学生的姓名和年龄,其中年龄为 18 - 25岁, // 超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止。 Student s = new Student(); Scanner sc = new Scanner(System.in); System.out.println(\"请输入姓名\"); String name = sc.nextLine(); s.setName(name); while(true){ System.out.println(\"请输入年龄\"); String ageStr = sc.nextLine(); try { int age = Integer.parseInt(ageStr); s.setAge(age); break; } catch (NumberFormatException e) { System.out.println(\"请输入一个整数\"); continue; } catch (AgeOutOfBoundsException e) { System.out.println(e.toString()); System.out.println(\"请输入一个符合范围的年龄\"); continue; } /*if(age &gt;= 18 &amp;&amp; age &lt;=25){ s.setAge(age); break; }else{ System.out.println(\"请输入符合要求的年龄\"); continue; }*/ } System.out.println(s); } }4.9 自定义异常1.什么是自定义异常？当Java中提供的异常不能满足我们的需求时,我们可以自定义异常2.为什么要 自定义异常？有一个原则 ：异常类要与业务相关3.实现步骤 定义异常类 写继承关系 提供空参构造 提供带参构造异常类public class AgeOutOfBoundsException extends RuntimeException { public AgeOutOfBoundsException() { } public AgeOutOfBoundsException(String message) { super(message); }}学生类public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { if(age &gt;= 18 &amp;&amp; age &lt;= 25){ this.age = age; }else{ //如果Java中提供的异常不能满足我们的需求,我们可以使用自定义的异常 throw new AgeOutOfBoundsException(\"年龄超出了范围\"); } } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; }}测试类public class ExceptionDemo12 { public static void main(String[] args) { // 键盘录入学生的姓名和年龄,其中年龄为 18 - 25岁, // 超出这个范围是异常数据不能赋值.需要重新录入,一直录到正确为止。 Student s = new Student(); Scanner sc = new Scanner(System.in); System.out.println(\"请输入姓名\"); String name = sc.nextLine(); s.setName(name); while(true){ System.out.println(\"请输入年龄\"); String ageStr = sc.nextLine(); try { int age = Integer.parseInt(ageStr); s.setAge(age); break; } catch (NumberFormatException e) { System.out.println(\"请输入一个整数\"); continue; } catch (AgeOutOfBoundsException e) { System.out.println(e.toString()); System.out.println(\"请输入一个符合范围的年龄\"); continue; } /*if(age &gt;= 18 &amp;&amp; age &lt;=25){ s.setAge(age); break; }else{ System.out.println(\"请输入符合要求的年龄\"); continue; }*/ } System.out.println(s); }}小结​ 1.什么是异常​ 程序中的不正常称为异常​ 2.异常的分类​ 编译期异常和运行时异常​ 3.谁处理异常?​ 原则上方谁调用谁处理，不想处理throws声明异常​ 实际开发过程中尽量不要让jvm来处理异常​ 4.如何捕获异常​ 通过try…catch来捕获​ 5.如何手动抛出异常​ throw new 异常类()​ 6.为什么要自定义异常​ 在实际开发过程中有很多异常是jdk没有帮我们定义好的，比如age负数或超出范围异常，因此我们需要根据实际的业务自定义异常​\t\t7.如何自定义异常​ 继承RuntimeException，调用父类中的带参构造方法" }, { "title": "面向对象-知识点API", "url": "/posts/JavaSE_advanced4/", "categories": "面向对象-知识点2", "tags": "后端", "date": "2022-09-02 06:34:00 +0000", "snippet": "面向对象-知识点23.API3.1 API概述 什么是API ​\tAPI (Application Programming Interface) ：应用程序编程接口 java中的API ​\t指的就是 JDK 中提供的各种功能的 Java类，这些类将底层的实现封装了起来，我们不需要关心这些类是如何实现的，只需要学习这些类如何使用即可，我们可以通过帮助文档来学习这些API如何使用。 3.2 API帮助文档 打开帮助文档 找到索引选项卡中的输入框 在输入框中输入Random 看类在哪个包下 看类的描述 看构造方法 看成员方法4.常用API4.1 Math 1、Math类概述 Math 包含执行基本数字运算的方法 2、Math中方法的调用方式 Math类中无构造方法，但内部的方法都是静态的，则可以通过 类名.进行调用 3、Math类的常用方法 方法名 方法名 说明 public static int abs(int a) 返回参数的绝对值 public static double ceil(double a) 返回大于或等于参数的最小double值，等于一个整数 public static double floor(double a) 返回小于或等于参数的最大double值，等于一个整数 public static int round(float a) 按照四舍五入返回最接近参数的int public static int max(int a,int b) 返回两个int值中的较大值 public static int min(int a,int b) 返回两个int值中的较小值 public static double pow (double a,double b) 返回a的b次幂的值 public static double random() 返回值为double的正值，[0.0,1.0) 4.2 System System类的常用方法 方法名 说明 public static void exit(int status) 终止当前运行的 Java 虚拟机，非零表示异常终止 public static long currentTimeMillis() 返回当前时间(以毫秒为单位) public static void arraycopy(数据源数组,起始索引,目的地数组,起始索引,拷贝个数) 将指定源数组中的数组从指定位置复制到目标数组的指定位置 示例代码 需求：在控制台输出1-10000，计算这段代码执行了多少毫秒 public class SystemDemo { public static void main(String[] args) { // 获取开始的时间节点 long start = System.currentTimeMillis(); for (int i = 1; i &lt;= 10000; i++) { System.out.println(i); } // 获取代码运行结束后的时间节点 long end = System.currentTimeMillis(); System.out.println(\"共耗时：\" + (end - start) + \"毫秒\"); //把arr1中的所有数据放在arr2数组中,而且是从arr2的3号索引开始 int[] arr1 = {12,34,56,78,99}; int[] arr2 = new int[10]; System.arraycopy(arr1,0,arr2,3,arr1.length); for (int i = 0; i &lt; arr2.length; i++) { System.out.println(arr2[i]); } }} 4.3 Object类的toString方法 Object类概述 Object 是类层次结构的根，每个类都可以将 Object 作为超类。所有类都直接或者间接的继承自该类，换句话说，该类所具备的方法，所有类都会有一份 查看方法源码的方式 选中方法，按下Ctrl + B 重写toString方法的方式 Alt + Insert 选择toString 在类的空白区域，右键 -&gt; Generate -&gt; 选择toString toString方法的作用： 以良好的格式，更方便的展示对象中的属性值 示例代码： class Student extends Object { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; }}public class ObjectDemo { public static void main(String[] args) { Student s = new Student(); s.setName(\"林青霞\"); s.setAge(30); System.out.println(s); System.out.println(s.toString()); }} 运行结果： Student{name='林青霞', age=30}Student{name='林青霞', age=30} 4.4 Object类的equals方法 equals方法的作用 用于对象之间的比较，返回true和false的结果 举例：s1.equals(s2); s1和s2是两个对象 重写equals方法的场景 不希望比较对象的地址值，想要结合对象属性进行比较的时候。 重写equals方法的方式 alt + insert 选择equals() and hashCode()，IntelliJ Default，一路next，finish即可 在类的空白区域，右键 -&gt; Generate -&gt; 选择equals() and hashCode()，后面的同上。 示例代码： class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public boolean equals(Object o) { //this -- s1 //o -- s2 if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Student student = (Student) o; //student -- s2 if (age != student.age) return false; return name != null ? name.equals(student.name) : student.name == null; }}public class ObjectDemo { public static void main(String[] args) { Student s1 = new Student(); s1.setName(\"林青霞\"); s1.setAge(30); Student s2 = new Student(); s2.setName(\"林青霞\"); s2.setAge(30); //需求：比较两个对象的内容是否相同 System.out.println(s1.equals(s2)); }} 面试题 // 看程序,分析结果String s = “abc”;StringBuilder sb = new StringBuilder(“abc”);s.equals(sb); sb.equals(s); public class InterviewTest { public static void main(String[] args) { String s1 = \"abc\"; StringBuilder sb = new StringBuilder(\"abc\"); //1.此时调用的是String类中的equals方法. //保证参数也是字符串,否则不会比较属性值而直接返回false //System.out.println(s1.equals(sb)); // false //StringBuilder类中是没有重写equals方法,用的就是Object类中的. System.out.println(sb.equals(s1)); // false }} 4.5 Objects 常用方法 方法名 说明 public static String toString(对象) 返回参数中对象的字符串表示形式。 public static String toString(对象, 默认字符串) 返回对象的字符串表示形式。 public static Boolean isNull(对象) 判断对象是否为空 public static Boolean nonNull(对象) 判断对象是否不为空 示例代码 学生类 class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; } } 测试类 public class MyObjectsDemo { public static void main(String[] args) { // public static String toString(对象): 返回参数中对象的字符串表示形式。 // Student s = new Student(\"小罗同学\",50); // String result = Objects.toString(s); // System.out.println(result); // System.out.println(s); // public static String toString(对象, 默认字符串): 返回对象的字符串表示形式。如果对象为空,那么返回第二个参数. //Student s = new Student(\"小花同学\",23); // Student s = null; // String result = Objects.toString(s, \"随便写一个\"); // System.out.println(result); // public static Boolean isNull(对象): 判断对象是否为空 //Student s = null; // Student s = new Student(); // boolean result = Objects.isNull(s); // System.out.println(result); // public static Boolean nonNull(对象): 判断对象是否不为空 //Student s = new Student(); Student s = null; boolean result = Objects.nonNull(s); System.out.println(result); } } 4.6 BigDecimal 作用 可以用来进行精确计算 构造方法 方法名 说明 BigDecimal(double val) 参数为double BigDecimal(String val) 参数为String 常用方法 方法名 说明 public BigDecimal add(另一个BigDecimal对象) 加法 public BigDecimal subtract (另一个BigDecimal对象) 减法 public BigDecimal multiply (另一个BigDecimal对象) 乘法 public BigDecimal divide (另一个BigDecimal对象) 除法 public BigDecimal divide (另一个BigDecimal对象，精确几位，舍入模式) 除法 总结 BigDecimal是用来进行精确计算的 创建BigDecimal的对象，构造方法使用参数类型为字符串的。 四则运算中的除法，如果除不尽请使用divide的三个参数的方法。 代码示例： BigDecimal divide = bd1.divide(参与运算的对象,小数点后精确到多少位,舍入模式);参数1 ，表示参与运算的BigDecimal 对象。参数2 ，表示小数点后面精确到多少位参数3 ，舍入模式 BigDecimal.ROUND_UP 进一法 BigDecimal.ROUND_FLOOR 去尾法 BigDecimal.ROUND_HALF_UP 四舍五入 " }, { "title": "面向对象-内部类&Lambda", "url": "/posts/JavaSE_advanced3/", "categories": "面向对象-知识点1", "tags": "后端", "date": "2022-09-02 06:34:00 +0000", "snippet": "面向对象-知识点11.内部类1.1 内部类-成员内部类1.什么是内部类在一个类中定义一个类。举例：在一个类A的内部定义一个类B，类B就被称为内部类，像这样👇/*\t格式： class 外部类名{ \t修饰符 class 内部类名{ \t \t} }*/class Outer { public class Inner { }}3 内部类的分类 在类的成员位置:成员内部类 在类方法内位置:局部内部类4 外部如何使用普通成员内部类？格式:外部类名.内部类名 对象名=new 外部对象().new 内部对象()范例: Outer.Inner oi=new Outer().new Inter();class Outer { private int a = 10; class Inner { int num = 10; public void show(){ System.out.println(\"Inner..show\"); // 内部类, 访问外部类成员, 可以直接访问, 包括私有 System.out.println(a); } }}5 成员内部类的访问非静态成员时的特点 内部类可以直接访问外部类的成员，包括私有 外部类要访问内部类的成员，必须创建对象1.2 私有成员内部类-静态成员内部类1.私有成员内部类的访问特点只能在自己所在的外部类中创建对象访问2.如何创建静态成员内部类对象？​\t外部类名.内部类名 对象名 = new 外部类名.内部类名();3.如何访问静态成员内部类中的静态方法？​\t外部类名.内部类名.方法名();示例代码1.3 局部内部类1.什么是局部内部类在方法中定义的类2.局部内部类如何使用？局部内部类，外界是无法直接使用，需要在方法内部创建对象并使用3.局部内部类的特点 局部内部类是在方法中定义的类 该类可以直接访问外部类的成员，也可以访问方法内的局部变量1.4 匿名内部类【重点】1.什么是匿名内部类？​\t特殊的局部内部类2 匿名内部类的前提存在一个类或者接口，这里的类可以是具体类也可以是抽象类3 如何使用匿名内部类？ 格式：new 类名 ( ) { 重写方法 } new 接口名 ( ) { 实现方法 } 举例： new Inter(){ @Override public void method(){}} 4 匿名内部类的本质​ 本质：是一个继承了该类或者实现了该接口的子类匿名对象​ 理解 : 匿名内部类是将(继承\\实现)(方法重写)(创建对象)三个步骤,放在了一步进行1.5 匿名内部类的应用场景【重点】 匿名内部类在开发中的使用 当某个方法的参数类型是一个接口或抽象类 类型 示例代码： public class TestSwimming { public static void main(String[] args) { goSwimming(new Swimming() { @Override public void swim() { System.out.println(\"铁汁, 我们去游泳吧\"); } }); } /** * 使用接口的方法 */ public static void goSwimming(Swimming swimming){ /* Swimming swim = new Swimming() { @Override public void swim() { System.out.println(\"铁汁, 我们去游泳吧\"); } } */ swimming.swim(); }} /* 游泳接口 */interface Swimming { void swim();} 小结1.什么是内部类在一个类中定义一个类2.内部类的分类？成员内部类和局部内部类3.如何使用成员内部类？格式:外部类名.内部类名 对象名=new 外部对象().new内部对象()范例: Outer.Inner oi=new Outer().new Inter();4. 成员内部类的访问时有什么特点 ？ 内部类可以直接访问外部类的成员，包括私有 外部类要访问内部类的非静态成员，必须创建对象5.私有成员内部类的访问特点？只能在自己所在的外部类中创建对象访问6.如何创建静态成员内部类对象？​\t外部类名.内部类名 对象名 = new 外部类名.内部类名();7.如何访问静态成员内部类中的静态方法？​\t静态成员内部类中的静态方法：外部类名.内部类名.方法名();8.局部内部类的使用方式 局部内部类，外界是无法直接使用，需要在方法内部创建对象并使用9.局部内部类的特点 局部内部类是在方法中定义的类 该类可以直接访问外部类的成员，也可以访问方法内的局部变量10.什么是匿名内部类？​\t没有显式的名字的内部类11 匿名内部类的前提存在一个类或者接口，这里的类可以是具体类也可以是抽象类12 如何使用匿名内部类？格式：new 类名 ( ) { 重写方法 } new 接口名 ( ) { 重写方法 }13. 匿名内部类的理解​ 是一个继承了该类或者实现了该接口的子类匿名对象14.匿名内部类的应用场景？当发现某个方法需要，接口或抽象类的子类对象，我们就可以传递一个匿名内部类过去，来简化传统的代码2.Lambda表达式2.1 Lambda表达式初体验和函数式编程思想1.什么是函数式编程的思想？在数学中，函数就是有输入量、输出量的一套计算方案，也就是“拿数据做操作”函数式思想则尽量忽略面向对象的复杂语法：“强调做什么，而不是以什么形式去做”2.面向对象思想和函数式编程思想对比面向对象思想强调“必须通过对象的形式来做事情”函数式思想则尽量忽略面向对象的复杂语法：“强调做什么，而不是以什么形式去做”2.2Lambda表达式的格式说明和前提条件【重点】1 Lambda表达式的前提条件有一个接口，接口中只能有一个抽象方法2 如何使用Lambda表达式？ 组成Lambda表达式的三要素：​ 形式参数，箭头，代码块​\t (形式参数) -&gt; {代码块} 形式参数：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可 -&gt;：由英文中画线和大于符号组成，固定写法。代表指向动作 代码块：是我们具体要做的事情，也就是以前我们写的方法体内容3 Lambda表达式练习示例代码public class TestLambda { /* Lambda表达式的使用前提 1. 一个接口 2. 接口中有且仅有一个抽象方法 练习1： 1. 编写一个接口（ShowHandler） 2. 在该接口中存在一个抽象方法（show），该方法是无参数无返回值 3. 在测试类（ShowHandlerDemo）中存在一个方法（useShowHandler） 方法的的参数是ShowHandler类型的 在方法内部调用了ShowHandler的show方法 */ public static void main(String[] args) { useShowHandler(new ShowHandler() { @Override public void show() { System.out.println(\"我是匿名内部类中的show方法\"); } }); // Lambda实现 useShowHandler( () -&gt; System.out.println(\"我是Lambda中的show方法\")); } public static void useShowHandler(ShowHandler showHandler){ showHandler.show(); }}interface ShowHandler { void show();}2.3 有参无返回值的Labmda表达式【应用】public class StringHandlerDemo { /* 1.首先存在一个接口（StringHandler） 2.在该接口中存在一个抽象方法（printMessage），该方法是有参数无返回值 3.在测试类（StringHandlerDemo）中存在一个方法（useStringHandler） 方法的的参数是StringHandler类型的 在方法内部调用了StringHandler的printMessage方法 */ public static void main(String[] args) { useStringHandler(new StringHandler() { @Override public void printMessage(String msg) { System.out.println(\"我是匿名内部类\" + msg); } }); // Lambda实现 useStringHandler( msg -&gt; System.out.println(\"我是Lambda表达式\" + msg)); } public static void useStringHandler(StringHandler stringHandler){ stringHandler.printMessage(\"itheima\"); }}interface StringHandler { void printMessage(String msg);}2.4Labmda表达式-无参数有返回值【应用】public class RandomNumHandlerDemo { /* 1. 首先存在一个接口（RandomNumHandler） 2. 在该接口中存在一个抽象方法（getNumber），该方法是无参数但是有返回值 3. 在测试类（RandomNumHandlerDemo）中存在一个方法（useRandomNumHandler） 方法的的参数是RandomNumHandler类型的 在方法内部调用了RandomNumHandler的getNumber方法 */ public static void main(String[] args) { useRandomNumHandler(new RandomNumHandler() { @Override public int getNumber() { Random r = new Random(); int num = r.nextInt(10) + 1; return num; } }); useRandomNumHandler( () -&gt; { Random r = new Random(); int num = r.nextInt(10) + 1; return num; // 注意: 如果lambda所操作的接口中的方法, 有返回值, 一定要通过return语句, 将结果返回 // 否则会出现编译错误 } ); } public static void useRandomNumHandler(RandomNumHandler randomNumHandler){ int result = randomNumHandler.getNumber(); System.out.println(result); }}interface RandomNumHandler { int getNumber();}2.5Labmda表达式-带参数带返回值【应用】public class CalculatorDemo { /* 1. 首先存在一个接口（Calculator） 2. 在该接口中存在一个抽象方法（calc），该方法是有参数也有返回值 3. 在测试类（CalculatorDemo）中存在一个方法（useCalculator） 方法的的参数是Calculator类型的 在方法内部调用了Calculator的calc方法 */ public static void main(String[] args) { useCalculator(new Calculator() { @Override public int calc(int a, int b) { return a + b; } }); useCalculator( ( a, b) -&gt; { return a + b; }); } public static void useCalculator(Calculator calculator){ int result = calculator.calc(10,20); System.out.println(result); }}interface Calculator { int calc(int a, int b);}2.6Lambda表达式的省略模式【应用】1.省略的规则 ​\t参数类型可以省略。但是有多个参数的情况下，不能只省略一个 ​\t如果参数有且仅有一个，那么小括号可以省略 ​\t如果代码块的语句只有一条，可以省略大括号和分号，和return关键字代码演示public class Test6 { public static void main(String[] args) { /*useInter( (double a, double b) -&gt; { return a + b; });*/ useInter( (a,b) -&gt; a + b ); } public static void useInter(Inter i) { double result = i.method(12.3, 22.3); System.out.println(result); }}interface Inter { // 用于计算 a + b 的结果并返回 double method(double a, double b);}2.7 Lambda表达式的应用场景当某个方法的参数类型是一个接口或抽象类类型,并且接口或抽象类中只有一个抽象方法2.8Lambda表达式和匿名内部类的区别 所需类型不同 匿名内部类：可以是接口，也可以是抽象类，还可以是具体类 Lambda表达式：只能是接口 使用限制不同 如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类 如果接口中多于一个抽象方法，只能使用匿名内部类，而不能使用Lambda表达式 实现原理不同 匿名内部类：编译之后，产生一个单独的.class字节码文件 Lambda表达式：编译之后，没有一个单独的.class字节码文件。对应的字节码会在运行的时候动态生成 小结1.什么是函数式编程思想函数式思想则尽量忽略面向对象的复杂语法：“强调做什么，而不是以什么形式去做”2.如何使用Lambda表达式？ 组成Lambda表达式的三要素：​ 形式参数，箭头，代码块​\t (形式参数) -&gt; {代码块} 形式参数：如果有多个参数，参数之间用逗号隔开；如果没有参数，留空即可 -&gt;：由英文中画线和大于符号组成，固定写法。代表指向动作 代码块：是我们具体要做的事情，也就是以前我们写的方法体内容3. Lambda表达式的前提条件有一个接口，接口中只能有一个抽象方法4.匿名内部类应用场景当某个方法的参数类型是一个接口或抽象类类型,并且接口或抽象类中只有一个抽象方法5.Lambda表达式和匿名内部类的区别 所需类型不同 匿名内部类：可以是接口，也可以是抽象类，还可以是具体类 Lambda表达式：只能是接口 使用限制不同 如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类 如果接口中多于一个抽象方法，只能使用匿名内部类，而不能使用Lambda表达式 实现原理不同 匿名内部类：编译之后，产生一个单独的.class字节码文件 Lambda表达式：编译之后，没有一个单独的.class字节码文件。对应的字节码会在运行的时候动态生成 " }, { "title": "面向对象-多态", "url": "/posts/JavaSE_advanced2/", "categories": "面向对象-多态", "tags": "后端", "date": "2022-09-02 06:34:00 +0000", "snippet": "面向对象-多态多态1.1 多态概述 多态：指的是同一个对象，在不同时刻表现出来的多种形态 我们可以说猫是猫：猫 cat = new 猫(); 我们也可以说猫是动物：动物 animal = new 猫(); 这里猫在不同的时刻表现出来了多种形态，这就是多态了解了什么是多态后，我们再来说一下多态的前提和体现： 有继承/实现关系 有方法重写 有父类引用指向子类对象public class Animal { public void eat() { System.out.println(\"动物吃东西\"); }}public class Cat extends Animal { @Override public void eat() { System.out.println(\"猫吃鱼\"); }}/* 多态的前提和体现 有继承/实现关系 有方法重写 有父类引用指向子类对象 */public class AnimalDemo { public static void main(String[] args) { //有父类引用指向子类对象 Animal a = new Cat(); }}1.2 多态中成员访问特点成员变量：编译看左边，执行看左边成员方法：编译看左边，执行看右边为什么成员变量和成员方法的访问不一样呢？因为成员方法有重写，而成员变量没有1.3 多态的好处和弊端多态的好处：提高了程序的扩展性具体体现：定义方法的时候，使用父类型作为参数，将来在使用的时候，使用具体的子类型参与操作多态的弊端：不能使用子类的特有功能1.4 多态中的转型多态的弊端是不能访问子类的特有功能，而通过转型就可以访问子类特有功能了。多态中的转型分为如下两种情况： 向上转型 从子到父 父类引用指向子类对象 向下转型 从父到子 父类引用转为子类对象 虽然我们通过向下转型解决了多态中的访问弊端，但是一般来说，我们使用多态的时候，主要还是使用父类中定义的通用功能。 1.5 多态转型内存图解1.6 案例：猫和狗(多态版)需求：请采用多态的思想实现猫和狗的案例，并在测试类中进行测试思路：① 定义动物类(Animal) 成员变量：姓名，年龄 构造方法：无参，带参 成员方法：get/set，吃(){}② 定义猫类(Cat)，继承动物类，重写吃的方法 构造方法：无参，带参 成员方法：吃(){}③ 定义狗类(Dog)，继承动物类，重写吃的方法 构造方法：无参，带参 成员方法：吃(){}④ 定义测试类(AnimalDemo)，写代码测试实现代码:public class Animal { private String name; private int age; public Animal() { } public Animal(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public void eat() { System.out.println(\"动物吃东西\"); }}public class Cat extends Animal { public Cat() { } public Cat(String name, int age) { super(name, age); } @Override public void eat() { System.out.println(\"猫吃鱼\"); }}public class Dog extends Animal { public Dog() { } public Dog(String name, int age) { super(name, age); } @Override public void eat() { System.out.println(\"狗吃骨头\"); }}/* 测试类 */public class AnimalDemo { public static void main(String[] args) { //按照多态的方式创建对象并进行测试 Animal a = new Cat(); a.setName(\"加菲\"); a.setAge(5); System.out.println(a.getName() + \",\" + a.getAge()); a.eat(); a = new Cat(\"加菲\", 5); System.out.println(a.getName() + \",\" + a.getAge()); a.eat(); }}创建狗类的对象进行测试同上。抽象类2.1 抽象类概述 在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类2.2 抽象类特点抽象类的特点： 抽象类和抽象方法必须使用 abstract 关键字修饰 public abstract class 类名 {} public abstract void eat(); 抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类 抽象类不能实例化 抽象类如何实例化呢？参照多态的方式，通过子类对象实例化，这叫抽象类多态 抽象类的子类 要么重写抽象类中的所有抽象方法 要么是抽象类 抽象类和普通类的区别: 普通类所拥有的的,抽象类都有,而且还多了一个抽象方法 2.3 抽象类的成员特点抽象类的成员特点： 成员变量 可以是变量 也可以是常量 构造方法 有构造方法，但是不能实例化 那么，构造方法的作用是什么呢？用于子类访问父类数据的初始化 成员方法 可以有抽象方法：限定子类必须完成某些动作 也可以有非抽象方法：提高代码复用性 2.4 案例：猫和狗(抽象类版)需求：请采用抽象类的思想实现猫和狗的案例，并在测试类中进行测试思路：① 定义动物类(Animal) 成员变量：姓名，年龄 构造方法：无参，带参 成员方法：get/set，吃();② 定义猫类(Cat)，继承动物类，重写吃的方法 构造方法：无参，带参 成员方法：吃(){…}③ 定义狗类(Dog)，继承动物类，重写吃的方法 构造方法：无参，带参 成员方法：吃(){…}④ 定义测试类(AnimalDemo)，写代码测试public abstract class Animal { private String name; private int age; public Animal() { } public Animal(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public abstract void eat();}public class Cat extends Animal { public Cat() { } public Cat(String name, int age) { super(name, age); } @Override public void eat() { System.out.println(\"猫吃鱼\"); }}public class Dog extends Animal { public Dog() { } public Dog(String name, int age) { super(name, age); } @Override public void eat() { System.out.println(\"狗吃骨头\"); }}/* 测试类 */public class AnimalDemo { public static void main(String[] args) { //创建对象，按照多态的方式 Animal a = new Cat(); a.setName(\"加菲\"); a.setAge(5); System.out.println(a.getName()+\",\"+a.getAge()); a.eat(); System.out.println(\"--------\"); a = new Cat(\"加菲\",5); System.out.println(a.getName()+\",\"+a.getAge()); a.eat(); }}接口3.1 接口概述接口很好理解，举例子这是我们生活当中的，其实与计算机相关的接口。键盘的USB插口、U盘的USB插口、鼠标的USB插口为什么是一摸一样的？因为电脑只提供了USB插口这种方式，如果说键盘的接口是Type-C的，那它就用不来哦。最后呢，我们来说一下： 接口就是一种公共的规范标准，只要符合规范标准，大家都可以通用 Java中的接口更多的体现在对行为的抽象3.2 接口特点接口的特点： 接口用关键字interface修饰 public interface 接口名 {} 类实现接口用implements表示 public class 类名 implements 接口名 {} 接口不能实例化 接口如何实例化呢？参照多态的方式，通过实现类对象实例化，这叫接口多态 多态的形式：具体类多态，抽象类多态，接口多态 多态的前提：有继承或者实现关系；有方法重写；有父(类/接口)引用指向(子/实现)类对象 接口的实现类 要么重写接口中的所有抽象方法 要么是抽象类 3.3 接口的成员特点接口的成员特点： 成员变量 只能是常量 默认修饰符：public static final 构造方法 没有，因为接口主要是扩展功能的，而没有具体存在 一个类如果没有父类，默认继承自Object类 成员方法 只能是抽象方法 默认修饰符：public abstract 3.4 类和接口的关系 类和类的关系 继承关系，只能单继承，但是可以多层继承 类和接口的关系 实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口 接口和接口的关系 继承关系，可以单继承，也可以多继承 3.5 抽象类和接口的区别 成员区别 抽象类 变量,常量；有构造方法；有抽象方法,也有非抽象方法 接口 常量；抽象方法 关系区别 类与类 继承，单继承 类与接口 实现，可以单实现，也可以多实现 接口与接口 继承，单继承，多继承 设计理念区别 抽象类 对类抽象，包括属性、行为 接口 对行为抽象，主要是行为 3.6 案例：木门和电动报警门需求：请采用面向对象的思想实现木门和电动报警门的案例，并在测试类中进行测试分析：分析：①木门 成员变量：宽，高，品牌 成员方法：开门，关门②电动报警门： 成员变量：宽，高，品牌 成员方法：开门，关门，报警思路：①定义报警 (Alarm)接口 成员方法：报警②定义门 (Door)抽象类 成员变量：宽，高，品牌 构造方法：无参，带参 成员方法：get/set方法，开门，关门③定义木门类(WoodDoor)，继承门类 构造方法：无参，带参 成员方法：开门，关门④定义电动报警门类(ElectricAlarmDoor),继承门类,实现报警接口 构造方法：无参，带参 成员方法：开门，关门，报警⑤定义测试类(DoorDemo)，创建对象进行测试实现代码：/* 报警接口 */public interface Alarm { void alarm();}/* 抽象门类 */public abstract class Door { //宽 private double width; //高 private double height; //品牌 private String brand; public Door() { } public Door(double width, double height, String brand) { this.width = width; this.height = height; this.brand = brand; } public double getWidth() { return width; } public void setWidth(double width) { this.width = width; } public double getHeight() { return height; } public void setHeight(double height) { this.height = height; } public String getBrand() { return brand; } public void setBrand(String brand) { this.brand = brand; } //开门 public abstract void open(); //关门 public abstract void close();}/* 木门 */public class WoodDoor extends Door { public WoodDoor() { } public WoodDoor(double width, double height, String brand) { super(width, height, brand); } @Override public void open() { System.out.println(\"手动开门\"); } @Override public void close() { System.out.println(\"手动关门\"); }}/* 电动报警门 */public class ElectricAlarmDoor extends Door implements Alarm { public ElectricAlarmDoor() { } public ElectricAlarmDoor(double width, double height, String brand) { super(width, height, brand); } @Override public void open() { System.out.println(\"自动开门\"); } @Override public void close() { System.out.println(\"自动关门\"); } @Override public void alarm() { System.out.println(\"具有报警功能\"); }}/* 测试类 */public class DoorDemo { public static void main(String[] args) { //木门 WoodDoor wd = new WoodDoor(); wd.open(); wd.close();// wd.alarm(); System.out.println(\"--------\"); //电动报警门 ElectricAlarmDoor ed = new ElectricAlarmDoor(); ed.open(); ed.close(); ed.alarm(); System.out.println(\"--------\"); //多态用法 Door d = new WoodDoor(); d.open(); d.close(); System.out.println(\"--------\"); d = new ElectricAlarmDoor(); d.open(); d.close();// d.alarm(); System.out.println(\"--------\"); Alarm a = new ElectricAlarmDoor();// a.open();// a.close(); a.alarm(); }}3.7 接口新增的方法接口组成： 常量 public static final 抽象方法 public abstract 默认方法(Java 8) 静态方法(Java 8) 私有方法(Java 9)但是呢，在Java 8 以后，我们可以在接口中添加默认方法和静态方法了。在Java 9以后，我们可以在接口中添加私有方法了。这里新增的3类方法我们自己在开发中很少使用，通常是Java源码中涉及到，对我们来说，能够识别语法，知道调用关系即可。先来看第一个默认方法：接口中默认方法的定义格式： 格式：public default 返回值类型 方法名(参数列表) { } 范例：public default void show1() { }接口中默认方法的注意事项： public可以省略，default不能省略再来看第二个静态方法：接口中静态方法的定义格式： 格式：public static 返回值类型 方法名(参数列表) { } 范例：public static void show2() { }接口中静态方法的注意事项： 静态方法只能通过接口名调用，不能通过实现类名或者对象名调用 public可以省略，static不能省略 最后来看第三个私有方法：接口中私有方法的定义格式： 格式1：private 返回值类型 方法名(参数列表) { } 范例1：private void show3() { } 格式2：private static 返回值类型 方法名(参数列表) { } 范例2：private static void show4() { }接口中私有方法的注意事项： 默认方法可以调用私有的静态方法和非静态方法 静态方法只能调用私有的静态方法" }, { "title": "面向对象-继承", "url": "/posts/JavaSE_advanced1/", "categories": "面向对象-继承", "tags": "后端", "date": "2022-09-02 06:34:00 +0000", "snippet": "面向对象-继承继承1.2 继承概述 继承是面向对象三大特征之一。(封装，继承，多态) 可以使得子类具有父类的属性和方法，还可以在子类中重新定义，追加属性和方法。继承的格式： 格式：public class 子类名 extends 父类名 { } 范例：public class Zi extends Fu { } Fu：是父类，也被称为基类、超类 Zi：是子类，也被称为派生类示例代码:public class Fu { public void show() { System.out.println(\"show方法被调用\"); }}public class Zi extends Fu { public void method() { System.out.println(\"method方法被调用\"); }}//测试类public class Demo { public static void main(String[] args) { //创建对象，调用方法 Fu f = new Fu(); f.show(); Zi z = new Zi(); z.method(); z.show(); }}继承中子类的特点： 子类可以有父类的内容 子类还可以有自己特有的内容1.3 好处和弊端继承的好处： 提高了代码的复用性(多个类相同的成员可以放到同一个类中) 提高了代码的维护性(如果方法的代码需要修改，修改一处即可)继承的弊端： 继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性什么时候使用继承： 继承体现的关系：is a 假设法：我有两个类A和B，如果他们满足A是B的一种，或者B是A的一种，就说明他们存在继承关系，这个时候就可以考虑使用继承来体现，否则就不能滥用继承1.4 继承中成员访问特点1.4.1 成员变量访问特点在子类方法中访问一个变量： 子类局部范围找 子类成员范围找 父类成员范围找 如果都没有就报错(不考虑父亲的父亲…)public class Fu { //年龄 public int age = 40;}public class Zi extends Fu { //身高 public int height = 175; //年龄 public int age = 20; public void show() { int age = 30; System.out.println(age); System.out.println(height); //报错// System.out.println(weight); }}//测试类public class Demo { public static void main(String[] args) { //创建对象，调用方法 Zi z = new Zi(); z.show(); }}1.4.2 super关键字super 关键字的用法和 this 关键字的用法相似 this：代表调用该方法的对象(一般我们是在当前类中使用this，所以我们常说this代表本类对象的引用) super：代表父类存储空间的标识(可以理解为父类对象引用)public class Fu { public int age = 40;}public class Zi extends Fu { public int age = 20; public void show() { int age = 30; System.out.println(age); //我要访问本类的成员变量age，怎么办呢？ System.out.println(this.age); //我要访问父类的成员变量age，怎么办呢？ System.out.println(super.age); }}//测试类public class Demo { public static void main(String[] args) { //创建对象，调用方法 Zi z = new Zi(); z.show(); }}1.4.3 构造方法访问特点 子类中所有的构造方法默认都会访问父类中无参的构造方法 因为子类会继承父类中的数据，可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化 每一个子类构造方法的第一条语句默认都是：super() 如果父类没有无参构造方法： ① 通过使用super关键字去显示的调用父类的带参构造方法 ② 在父类中自己提供一个无参构造方法 推荐：自己给出无参构造方法1.4.4 成员方法访问特点通过子类对象访问一个方法： 子类成员范围找 父类成员范围找 如果都没有就报错(不考虑父亲的父亲…)1.5 方法重写什么是方法重写 子类中出现了和父类中一模一样的方法声明(返回值类型,方法名,参数列表)方法重写的应用场景：如果说父类满足不了子类当前的需求了,那么就应该使用重写 当子类需要父类的功能，而功能主体子类有自己特有内容时，可以重写父类中的方法，这样，即沿袭了父类的功能，又定义了子类特有的内容 练习：手机类和新手机类/* 手机类 */public class Phone { public void call(String name) { System.out.println(\"给\" + name + \"打电话\"); }}/* 新手机 */public class NewPhone extends Phone { /* public void call(String name) { System.out.println(\"开启视频功能\");// System.out.println(\"给\" + name + \"打电话\"); super.call(name); } */ @Override public void call(String name) { System.out.println(\"开启视频功能\");// System.out.println(\"给\" + name + \"打电话\"); super.call(name); }}/* 测试类 */public class PhoneDemo { public static void main(String[] args) { //创建对象，调用方法 Phone p = new Phone(); p.call(\"林青霞\"); System.out.println(\"--------\"); NewPhone np = new NewPhone(); np.call(\"林青霞\"); }}1.6 继承的注意事项 Java中类只支持单继承，不支持多继承 Java中类支持多层继承public class Granddad { public void drink() { System.out.println(\"爷爷爱喝酒\"); }}public class Father extends Granddad { public void smoke() { System.out.println(\"爸爸爱抽烟\"); }}public class Mother { public void dance() { System.out.println(\"妈妈爱跳舞\"); }}/*public class Son extends Father, Mother {}*/public class Son extends Father {}1.7 继承案例1.7.1 老师和学生需求：定义老师类和学生类，然后写代码测试；最后找到老师类和学生类当中的共性内容，抽取出一个父类，用继承的方式改写代码，并进行测试看完需求后，我们先简单的说一下思路：思路：①定义老师类(姓名，年龄，教书())②定义学生类(姓名，年龄，学习())③定义测试类，写代码测试/* 老师类 */public class Teacher { private String name; private int age; public Teacher() { } public Teacher(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public void teach() { System.out.println(\"用爱成就每一位学员\"); }}/* 学生类 */public class Student { private String name; private int age; public Student() { } public Student(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public void study() { System.out.println(\"好好学习天天向上\"); }}/* 测试类 */public class Demo { public static void main(String[] args) { //创建老师类对象进行测试 Teacher t1 = new Teacher(); t1.setName(\"林青霞\"); t1.setAge(30); System.out.println(t1.getName() + \",\" + t1.getAge()); t1.teach(); Teacher t2 = new Teacher(\"风清扬\", 33); System.out.println(t2.getName() + \",\" + t2.getAge()); t2.teach(); //学生类的测试，留给大家自己练习 }}④共性抽取父类，定义人类(姓名，年龄)⑤定义老师类，继承人类，并给出自己特有方法：教书()⑥定义学生类，继承人类，并给出自己特有方法：学习()⑦定义测试类，写代码测试/* 人类 */public class Person { private String name; private int age; public Person() { } public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; }}/* 老师类 */public class Teacher extends Person { public Teacher() { } public Teacher(String name, int age) {// this.name = name;// this.age = age; super(name, age); } public void teach() { System.out.println(\"用爱成就每一位学员\"); }}/* 测试类 */public class PersonDemo { public static void main(String[] args) { //创建老师类对象并进行测试 Teacher t1 = new Teacher(); t1.setName(\"林青霞\"); t1.setAge(33); System.out.println(t1.getName() + \",\" + t1.getAge()); t1.teach(); Teacher t2 = new Teacher(\"风清扬\", 36); System.out.println(t2.getName() + \",\" + t2.getAge()); t2.teach(); //学生类的定义和测试，留给大家自学练习 }}1.7.2 项目经理和程序员需求：请使用继承的思想设计出项目经理类和程序员类，并进行测试。看完这个需求后，我们首先得知道项目经理和程序员都有哪些属性和行为，这样我们才能够设计这两个类，通过这两个类的共性特性，设计出一个父类。这里呢，我们给出项目经理和程序员的成员变量和成员方法：项目经理：​\t成员变量：工号，姓名，工资，奖金​\t成员方法：工作程序员：​\t成员变量：工号，姓名，工资​\t成员方法：工作通过分析，我们可以找到它们的共性内容，设计出一个父类：员工类员工类：​\t成员变量：工号，姓名，工资​\t成员方法：工作程序员类继承自员工类，没有新的成员需要添加。而项目经理类继承自员工类，需要添加一个成员变量：奖金。下面给出实现思路：思路：①定义员工类(工号，姓名，工资，工作())②定义项目经理类，继承自员工类，添加一个新的成员变量奖金③定义程序员类，不需要添加新的成员④定义测试类，进行测试分析完毕后，我们到IDEA中去实现一下：/* 员工类 */public class Employee { //工号 private String id; //姓名 private String name; //薪水 private double salary; public Employee() { } public Employee(String id, String name, double salary) { this.id = id; this.name = name; this.salary = salary; } public String getId() { return id; } public void setId(String id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public double getSalary() { return salary; } public void setSalary(double salary) { this.salary = salary; } public void work() { System.out.println(\"员工需要工作\"); }}/* 项目经理类 */public class Manager extends Employee { //奖金 private double bonus; public Manager() { } public Manager(String id, String name, double salary, double bonus) { super(id, name, salary); this.bonus = bonus; } public double getBonus() { return bonus; } public void setBonus(double bonus) { this.bonus = bonus; } @Override public void work() { System.out.println(\"项目经理和客户谈需求\"); }}/* 程序员类 */public class Programmer extends Employee { public Programmer() { } public Programmer(String id, String name, double salary) { super(id, name, salary); } @Override public void work() { System.out.println(\"程序员根据需求编写代码\"); }}/* 测试类 */public class EmployeeDemo { public static void main(String[] args) { //创建项目经理类对象，并进行测试 Manager m1 = new Manager(); m1.setId(\"itheima001\"); m1.setName(\"林青霞\"); m1.setSalary(10000.00); m1.setBonus(20000.00); System.out.println(m1.getId() + \",\" + m1.getName() + \",\" + m1.getSalary() + \",\" + m1.getBonus()); Manager m2 = new Manager(\"itheima001\", \"林青霞\", 10000.00, 20000.00); System.out.println(m2.getId() + \",\" + m2.getName() + \",\" + m2.getSalary() + \",\" + m2.getBonus()); System.out.println(\"-------------------------------\"); //创建程序员类对象，并进行测试 Programmer p1 = new Programmer(); p1.setId(\"itheima520\"); p1.setName(\"风清扬\"); p1.setSalary(20000.00); System.out.println(p1.getId() + \",\" + p1.getName() + \",\" + p1.getSalary()); Programmer p2 = new Programmer(\"itheima520\", \"风清扬\", 20000.00); System.out.println(p2.getId() + \",\" + p2.getName() + \",\" + p2.getSalary()); }}修饰符2.1 权限修饰符修饰符的分类： 权限修饰符 状态修饰符package com.itheima_01;public class Fu { private void show1() { System.out.println(\"private\"); } void show2() { System.out.println(\"默认\"); } protected void show3() { System.out.println(\"protected\"); } public void show4() { System.out.println(\"public\"); } public static void main(String[] args) { //创建Fu的对象，测试看有哪些方法可以使用 Fu f = new Fu(); f.show1(); f.show2(); f.show3(); f.show4(); }}package com.itheima_01;public class Zi extends Fu { public static void main(String[] args) { //创建Zi的对象，测试看有哪些方法可以使用 Zi z = new Zi(); z.show2(); z.show3(); z.show4(); }}package com.itheima_01;public class Demo { public static void main(String[] args) { //创建Fu的对象，测试看有哪些方法可以使用 Fu f = new Fu(); f.show2(); f.show3(); f.show4(); }}package com.itheima_02;import com.itheima_01.Fu;public class Zi extends Fu { public static void main(String[] args) { //创建Zi的对象，测试看有哪些方法可以使用 Zi z = new Zi(); z.show3(); z.show4(); }}package com.itheima_02;import com.itheima_01.Fu;public class Demo { public static void main(String[] args) { //创建Fu的对象，测试看有哪些方法可以使用 Fu f = new Fu(); f.show4(); }}总结：public（公众） &gt; protected &gt; 默认 &gt; private（私有）2.2 final2.2.1 final关键字状态修饰符的分类： final(最终态) static(静态) final 关键字是最终的意思，可以修饰成员方法，成员变量，类final 修饰的特点 修饰方法：表明该方法是最终方法，不能被重写 修饰变量：表明该变量是常量，不能再次被赋值 修饰类：表明该类是最终类，不能被继承2.2.2 final修饰局部变量final修饰局部变量： 变量是基本类型：final 修饰指的是基本类型的数据值不能发生改变 变量是引用类型：final 修饰指的是引用类型的地址值不能发生改变，但是地址里面的内容是可以发生改变的 2.3 static2.3.1 static关键字 static关键字是静态的意思，可以修饰成员方法，成员变量static 修饰的特点 被类的所有对象共享，这也是我们判断是否使用静态关键字的条件 可以通过类名调用，当然，也可以通过对象名调用，推荐使用类名调用 2.3.2 static访问特点非静态的成员方法 能访问静态的成员变量 能访问非静态的成员变量 能访问静态的成员方法 能访问非静态的成员方法静态的成员方法 能访问静态的成员变量 能访问静态的成员方法总结成一句话就是：静态成员方法只能访问静态成员2.3.3 main方法详细说明main方法的声明：public static void main(String[] args) { } public 被jvm调用，访问权限足够大 static 被jvm调用，不用创建对象，直接类名访问 void 被jvm调用，不需要给jvm返回值 main 一个通用的名称，虽然不是关键字，但是被jvm识别 String[] args 以前用于接收键盘录入的通过args接收数据，参数的配置：第一步：选择HelloWorld下面的Edit Configurations…第二步：配置参数，数据之间用空格隔开但极少人用了。2.3.4 static应用：工具类static的应用有很多，这里我们讲解其中的一个，就是static关键字在工具类中的使用。/* 工具类： 构造方法私有 成员静态修饰 */public class ArrayTool { //构造方法私有 private ArrayTool() { } public static int getMax(int[] arr) { int max = arr[0]; for (int i = 1; i &lt; arr.length; i++) { if (arr[i] &gt; max) { max = arr[i]; } } return max; }}public class ArrayDemo { public static void main(String[] args) { //定义一个数组 int[] arr = {12, 56, 78, 93, 40}; //需求：获取数组中最大值// int max = arr[0];//// for (int i = 1; i &lt; arr.length; i++) {// if (arr[i] &gt; max) {// max = arr[i];// }// } //创建对象调用// ArrayTool at = new ArrayTool();// int max = at.getMax(arr); //调用类的静态方法 int max = ArrayTool.getMax(arr); System.out.println(\"数组中最大值是：\" + max); }}工具类的特点： 构造方法私有 成员用static修饰2.3.5 Math类使用(自学) Math类是：数学工具类，包含对数学运算的方法 帮助文档中，没有看到构造方法，因为成员都用static修饰了，可以通过类名直接访问示例：/* Math类的使用 */public class MathDemo { public static void main(String[] args) { //public static int abs(int a):返回int值的绝对值 System.out.println(Math.abs(10)); System.out.println(Math.abs(-10)); System.out.println(\"-----------\"); //public static int max(int a, int b):返回两个int值中较大的int System.out.println(Math.max(10, 20)); System.out.println(\"-----------\"); //public static double pow(double a, double b):返回第一个参数的值，该值是第二个参数的幂 System.out.println(Math.pow(2, 3)); System.out.println(\"-----------\"); //public static long round(double a):返回与参数最接近的long System.out.println(Math.round(15.4)); System.out.println(Math.round(15.5)); }}" }, { "title": "Everything", "url": "/posts/Everything/", "categories": "Everything", "tags": "好用小玩意", "date": "2022-09-01 12:34:00 +0000", "snippet": "Everything简介\"Everything\" 是 Windows 上一款搜索引擎，它能够基于文件名快速定文件和文件夹位置。不像 Windows 内置搜索，\"Everything\" 默认显示电脑上每个文件和文件夹 搜索框输入的关键词将会筛选显示的文件和文件夹。个人评价用了很长时间总体感觉还不错，页面简洁功能性强。其实现在的电脑刚买的时候还好，电脑里系统文件也不多，自己平时用的东西也不会有多少文件。 但慢慢时间长了以后，尤其是经常用电脑的伙计们，比如我，我电脑从买到现在也就半年，整个电脑一百多万份文件，平常自己找个文件最多翻一会就能找到，一旦找那种刁钻的文件，确实不是很容易好找。下载安装包中文官网：Everything云盘下载：Everything" }, { "title": "MySQL", "url": "/posts/MySQL/", "categories": "MySQL", "tags": "后端", "date": "2022-08-31 12:34:00 +0000", "snippet": "一、下载官网链接：MySQL云盘链接：MySQL 提取码（mysq）选择选择和自己系统位数相对应的版本点击右边的Download，此时会进到另一个页面，同样在接近页面底部的地方找到如下图所示的位置：不用理会上面的登录和注册按钮，直接点击No thanks, just start my download.就可以下载。二、安装(解压)下载完成后我们得到的是一个压缩包，将其解压，我们就可以得到MySQL 5.7.24的软件本体了(就是一个文件夹)，我们可以把它放在你想安装的位置。三、配置添加环境变量右键此电脑→属性，点击高级系统设置点击环境变量在系统变量中新建MYSQL_HOME在系统变量中找到并双击Path点击新建最后点击确定。如何验证是否添加成功？右键开始菜单(就是屏幕左下角)，选择命令提示符(管理员)，打开黑框，敲入mysql，回车。如果提示Can't connect to MySQL server on 'localhost'则证明添加成功；如果提示mysql不是内部或外部命令，也不是可运行的程序或批处理文件则表示添加添加失败，请重新检查步骤并重试。新建配置文件新建一个文本文件，内容如下：[mysql]default-character-set=utf8[mysqld]character-set-server=utf8default-storage-engine=INNODBsql_mode=STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION把上面的文本文件另存为，在保存类型里选所有文件 (*.*)，文件名叫my.ini，存放的路径为MySQL的根目录(例如我的是D:\\software\\mysql-5.7.24-winx64,根据自己的MySQL目录位置修改)。上面代码意思就是配置数据库的默认编码集为utf-8和默认存储引擎为INNODB。初始化MySQL在刚才的黑框中敲入mysqld --initialize-insecure，回车，稍微等待一会，如果出现没有出现报错信息(如下图)则证明data目录初始化没有问题，此时再查看MySQL目录下已经有data目录生成。mysqld --initialize-insecuretips：如果出现如下错误是由于权限不足导致的，去C:\\Windows\\System32 下以管理员方式运行 cmd.exe注册MySQL服务在黑框里敲入mysqld -install，回车。mysqld -install现在你的计算机上已经安装好了MySQL服务了。MySQL服务器启动MySQL服务在黑框里敲入net start mysql，回车。net start mysql // 启动mysql服务 net stop mysql // 停止mysql服务修改默认账户密码在黑框里敲入mysqladmin -u root password 1234，这里的1234就是指默认管理员(即root账户)的密码，可以自行修改成你喜欢的。mysqladmin -u root password 1234至此，MySQL 5.7 解压版安装完毕！四、登录MySQL右键开始菜单，选择命令提示符，打开黑框。在黑框中输入，mysql -uroot -p1234，回车，出现下图且左下角为mysql&gt;，则登录成功。mysql -uroot -p1234到这里你就可以开始你的MySQL之旅了！退出mysql：exitquit登陆参数：mysql -u用户名 -p密码 -h要连接的mysql服务器的ip地址(默认127.0.0.1) -P端口号(默认3306)五、卸载MySQL如果你想卸载MySQL，也很简单。右键开始菜单，选择命令提示符(管理员)，打开黑框。 敲入net stop mysql，回车。net stop mysql 再敲入mysqld -remove mysql，回车。mysqld -remove mysql 最后删除MySQL目录及相关的环境变量。至此，MySQL卸载完成！" }, { "title": "群晖", "url": "/posts/%E7%BE%A4%E6%99%96/", "categories": "群晖", "tags": "好用小玩意", "date": "2022-08-30 04:34:00 +0000", "snippet": "群晖安装FlexGet配合qBittorrent实现监控下载一、前言监控下载思路：使用FlexGet订阅站点RSS自动下载种子到群辉上某个（或多个）文件夹，qBittorrent监控该文件夹，发现有新的种子自动开始下载。本文适合有一定的linux基础的同学操作，严格按照下属步骤即可完成安装。建议：能复制就不要手写，如果安装失败请仔细核对是否严格按照步骤要求操作。这种方案适合下载PT站官方的免费种子，否要小心自己的分享率了！！！因为该教程造成的分享率下降，本文概不负责！！！因为该教程造成的分享率下降，本文概不负责！！！因为该教程造成的分享率下降，本文概不负责！！！二、安装Python从群晖套件中心安装python3，记住安装到的磁盘，以volume1为例。三、安装FlexGet1. 安装pip并更新pip #以root账户ssh登录群辉切换到python的bin目录 cd /volume1/@appstore/py3k/usr/local/bin # 安装pip ./python3 -m ensurepip # 更新pip ./python3 -m pip install --upgrade pip2. 创建virtualenv容器（推荐） # 安装 virtualenv ./python3 -m pip install -i https://pypi.tuna.tsinghua.edu.cn/simple virtualenv # 安装成功后创建一个virtualenv环境 ./virtualenv ./flexget/ # 切换到 flexget 的 Virtualenv目录 cd flexget # 启动virtualenv 环境【成功启动后会在命令行左侧有flexget标示】 source bin/activate3. 安装flexget bin/pip install -i https://pypi.tuna.tsinghua.edu.cn/simple flexget这个过程下载的内容比较多，适你的网络情况而定，下载完成后会有done的提示。4. 安装完毕后退出virtualenv deactivate 四、配置并启动FlexGet1. 配置config.yml​ 配置文件默认位置/root/.config/flexget/config.yml，如果没有该路径请创建，同时日志文件也会存在该路径下。​ 配置配置文件config.yml，推荐本地编辑好之后使用winscp/hsf+wget等方式上传到指定位置。下面是配置文件的模板 web_server: bind: 0.0.0.0 port: 1025 #web-ui的监听端口 #SSL证书位置，启用https的话，把前面的#号删除 # ssl_certificate: '/etc/ssl/private/myCert.pem' #SSL证书位置，启用https的话，把前面的#号删除 # ssl_private_key: '/etc/ssl/private/myKey.key' web_ui: yes #启用web-ui base_url: /flex #网址后缀 run_v2: yes #启动 V2 版本 tasks: PTer: rss: 你的rss地址 accept_all: no #是否全部下载，不想过滤就yes然后把downlod之前的全删了 if: #启用 if 条件过滤 - \"'PTer' in title\": accept #这里可以多行，指定不同的规则 #- \"'DEF' in title\": reject #标题含有 DEF 就不下载 download: /volume3/Download/PT/Torrent_Monitor #种子下载路径，即qb监视路径 qbittorrent: #qb服务器信息 host: localhost port: 8080 username: qb的web用户名 password: qb的web密码 path: /volume3/Download/PT/Common #文件下载路径 schedules: - tasks: PTer #多个任务这样写[Pter,M-team] interval: minutes: 5 #任务执行时间间隔2. 设置Web登录密码 /volume1/@appstore/py3k/usr/local/bin/flexget/bin/flexget web passwd 你的密码默认用户名是：flexget，请注意密码强度有要求。3. 以守护进程方式启动 /volume1/@appstore/py3k/usr/local/bin/flexget/bin/flexget daemon start -d4. 添加开机启动编辑 /etc/rc.local 脚本(如果没有该文件就创建)，在 exit 0 前面（前一行）添加以下内容并保存 /volume1/@appstore/py3k/usr/local/bin/flexget/bin/flexget daemon start -d重启后，SSH 登录到 shell,在终端内输入以下内容，有 flexget 的进程，就说明启动成功了。 ps -aux | grep flexget5. 访问网页测试 http://ip:50123/flex/如果要外网访问，请设置好端口转发，出现页面后表示启动并配置成功，使用之前设置的用户名和密码即可登录管理。五、其他设置qBittorrent的监控目录为flexget的种子下载目录在qBittorrent的webui页面，点击齿轮设置》下载》自动从此处添加 torrents：处添加监视文件夹即可。六、引用参考 群晖安装FlexGet配合qBittorrent实现监控下载 本文转载自sunxiaowei" }, { "title": "云盘变硬盘", "url": "/posts/%E4%BA%91%E7%9B%98%E5%8F%98%E7%A1%AC%E7%9B%98/", "categories": "云盘变硬盘", "tags": "好用小玩意", "date": "2022-08-29 09:34:00 +0000", "snippet": "阿里云盘变本地硬盘介绍将云盘功能挂载到本地计算机设备上，达到新增0成本为计算机新增个硬盘的效果。优点：空间够大，数据更安全，和计算机自带盘符没差别。缺点：需要良好的网络环境，没网那这个云盘就用不了。获得软件网盘提取资源：软件提取 提取码（alyp），按需求安装32位或64位。安装软件双击安装包执行安装流程，更改安装位置为D盘某路径，然后一路Next安装完成。自动跳转到浏览这个页面之后填邮箱填密码注册一下登录进去。登陆的时候账号是否同步到云端？不建议。挂载云盘登录之后开始挂载云盘登录手机端阿里云盘软件登录此网站登录成功过后出现如下图标选择你的阿里云盘并挂载选择挂载点随便一个你本地没有的盘符确定挂载验证挂载成功点击顶格小电视图标显示你刚刚挂载的云盘（可挂载多个云盘）发现本地多了个盘符总结此软件实现了云盘服务和本地服务的高速互通互联。" }, { "title": "Git", "url": "/posts/Git/", "categories": "Git", "tags": "版本控制工具", "date": "2022-08-29 09:34:00 +0000", "snippet": "分布式版本控制系统工具Git概念目前世界上最先进的分布式版本控制系统---Git。能够记录每次文件的改动，并且能协调多用户编辑。Git？Github？Git：一个分布式版本控制系统，说简单点Git就是软件。Github：全球最大的基友网站，可以理解是一个为用户提供Git服务的网络平台网站（代码托管云平台），除了具有Git的功能外，还提供了很多丰富的功能。Github注册Github官网不知道怎么注册？点这Git安装官网下载：Git云盘下载：Git 提取码（git6）下载后得到一个安装包，点击安装即可，一路Next安装。唯一要注意的是更改安装目录不能含有中文和空格。到最后一步取消这个勾选，点击Finish安装完成。验证安装如果你在桌面右击有这两个选项，那就是安装完成了。使用Git（理论）Git在本地操作的三个区域。工作区（Working Directory）：添加编辑修改文件等动作。Git指令：git add 暂存区：暂存已经修改的文件最后统一提交到git仓库中。 Git指令：git commit -m \"文字描述\"Git Repository(Git仓库)：最终确认的文件保存到仓库，成为一个新版本，并且对他人可见。什么是仓库？仓库又叫版本库，可以简单理解为一个用于存代码的目录，这个目录里所有的文件都可以被Git管理起来，这个目录里所有的文件修改删除等操作Git都能检测跟踪到。使用Git（实操）1.安装好之后需要进行全局配置桌面右击点开Git Bash Here 打开Git命令窗口。2.设置Git用户git config --global user.name \"你github用户名或者你gitee用户名\"git config --global user.email \"你github注册邮箱或者你gitee注册邮箱\"如何知道设置成功了？继续在Git命令窗敲指令git config --global user.name如果显示出你github用户名或者你gitee用户名，那就是设置成功了。git config --global user.email如果显示出你github注册邮箱或者你gitee注册邮箱，那就是显示成功了，之后关掉这个命令窗口。3.在D盘里创建一个新文件夹作为新仓库（仓库路径包括仓库名字不得带有中文字符或者空格）。打开这个文件夹进行如下操作：输入指令进行仓库初始化git init敲完回车之后文件夹出现.git文件夹，那就说明这个仓库初始化成功了。常用常用指令查看当前状态git status添加到缓存区git add提交到本地仓库git commit -m \"注释内容\"人间后悔药–版本回退步骤：1.查看版本，确定需要回去的时刻点 指令： git log git log --pretty=oneline2.回退操作 指令： git reset --hard 提交编号注意回到过去时间段版本之后，如果想回到未来时间段版本，你会发现之前的版本回退指令不好使了，完犊子了回不去了。莫慌，想回到未来时间段版本，需要用到新的指令：git reflog熟练的使用这几个指令，可以让你在过去时间段和未来时间段之间反复横跳。小结1.想回到过去，必须先得到commit id（就是提交编号），然后通过git reset –hard进行回退。2.想要回到未来，需要使用git reflog进行历史查看，得到最新的commit id。3.在写回退指令时，commit id 可以不用写全，Git会自动识别但至少要写出四位字符。" }, { "title": "IDM", "url": "/posts/IDM/", "categories": "IDM", "tags": "好用小玩意", "date": "2022-08-28 12:34:00 +0000", "snippet": "IDM是个啥概念​\t\tIDM是个强大的脚本插件，IDM脚本在资本主义日渐猖獗的背景下，被互联网大佬们创作出来，主要作用于百度网盘的下载限速的问题。​\t\t百度网盘如今店大欺客，限制下载速度不是一年两年了，早就引发社会主义人民的众怒，IDM的问世，就是善良的社会主义人民的”重拳出击”，狠狠的打了丑恶资本主义的一个大逼兜。如何习得“重拳”技能？先下载油猴油猴下载地址下载过程点击下载（黑色的那个）点击安装（点Add to Firefox）点击添加（添加A）好的油猴安装后浏览器扩展多个 鼻孔 似的的图标（右边第一排倒数第二个）点击鼻孔（选择获取新脚本）在搜索框直接搜百度网盘选择如图 网盘直链下载助手，千万不要下载错了点击安装再点击安装跳到这之后不用点安装了，到这一步就算成了。注意！​\t\t油猴是一个开放性的脚本管理插件系统，所以油猴里的部分脚本或部分扩展有不确定性，可能含有威胁，不要随意下载使用。安装IDM云盘提取：IDM 提取码（idm6）提取完得到一个压缩包，解压到你想解压的地方。解压完之后得到一个目录长这样👇👇👇注意！​\t\t安装完之后就行了，不用管了。看到绿化这两个字眼，应该都能明白什么意思，懂得都懂。不懂点这如何使用”重拳“技能？随便找个百度网盘资源连接，到刚刚安装好油猴的浏览器打开它，你会发现你的百度网盘资源下载界面多了个下载助手。点击API下载点击如图链接（因为第一次使用，所以响应比较慢，稍等一会就好了）之后刚刚安装好的IDM就会弹出文件下载信息，可以选择下载路径可以看到下载速度6.499MB/秒，速度还是很理想的。总结​\t\tTemplemonkey是一个可以让Chrome支持更多chrome不支持的脚本的Chrome扩展 ，Temple monkey里面有很多脚本，包括网盘直链下载助手脚本。​\t\tidm是个资源下载管理器说白了就是个资源下载管理器， idm可以捕捉到网页中存在的资源并提示下载， 它可以利用多线程提高用户所占服务器的宽带，但是如果资源本身就做了低速处理，或者宽带的速度本来就并不快 idm就算再🐂🍺也突破不了这些限制。​\t\t在浏览器没有安装油猴里面的网盘直链下载助手脚本时，idm是不能捕捉到网页资源的，因为资源本身做了限制，脚本的作用就是突破这些限制，能让idm捕捉到网页的资源" }, { "title": "Tomcat", "url": "/posts/Tomcat/", "categories": "Tomcat", "tags": "轻量级应用服务器", "date": "2022-08-28 11:34:00 +0000", "snippet": "轻量级应用服务器概念\tTomcat，一个免费的轻量级的Web服务器，Apache软件基金会的一个核心项目，开源免费使它深得人们喜爱。 那它到底是什么呢，没错，它就是一只叫Tom的猫。就长这样👇👇👇如何部署首先你得有一个Tomcat安装包官网下载：Tomcat云盘提取：Tomcat提取码（tomc）然后把安装包解压到D盘的某个角落，如果你得到了一个apache-tomcat-8.5.68目录，那说明你的D盘多了一个新目录。点进新目录长这样走到这一步的话就说明把这一步走了。问：如何卸载Tomcat？卸载Tomcat。如何使用双击新目录下的bin\\startup.bat 就是它👇之后会弹出个黑框口跳出一堆你看不懂的代码，等它跳完后不要关掉黑框口，直接浏览器输入http://localhost:8080 你就会得到一只体态优雅，形貌俊俏，美感拉满的一只叫Tom的🐱。如何关闭1.直接X掉黑窗口2.在黑窗口输入ctrl+c（我用这种）3.双击文件夹目录下的bin\\shutdown.bat文件特殊情况如果说在 双击新目录下的bin\\startup.bat 这一步之后没有黑窗口弹出，或者有什么东西一闪而过，那就惨啦老弟儿，换电脑吧。🌚🌑🌒🌓🌔🌕🌝开玩笑的，这其实大概率只是我们的电脑端口冲突了而已，解决方法下面这位博主做的不错，可以参考一下。八大异常解决实在不行就给我发邮件，当然我也不一定能看得到 /手动滑稽/ 。" }, { "title": "JavaScript", "url": "/posts/JavaScript/", "categories": "JavaScript", "tags": "前端", "date": "2022-08-28 03:00:00 +0000", "snippet": "JavaScript脚本编程语言概念\t丫就是在Java基础上被开发出来的一门语言，说Java是它亲爹都不过分，很好的继承了Java跨平台，面向对象的特性。 青出于蓝的是JavaScript的代码文件不需要像Java代码文件那样先编译再运行，它的代码文件可以直接被浏览器解析并运行。 JavaScript脚本编程语言在前端网页开发的江湖地位挺高，用于控制网页 行为 ，使网页交互，与CSS，HTML并称前端三剑客。用法HTML中的Javascript脚本代码必须位于&lt;script&gt;&lt;/script&gt;标签之间。Javascript脚本代码可被放置在HTML页面的&lt;body&gt;和&lt;head&gt;部分中。如这样： &lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;..&lt;script&gt;document.write(\"&lt;h1&gt;这是一个标题&lt;/h1&gt;\");document.write(\"&lt;p&gt;这是一个段落&lt;/p&gt;\");&lt;/script&gt;..&lt;/body&gt;&lt;/html&gt;常用对象参考再多就往这看有种你点我" }, { "title": "HTML", "url": "/posts/HTML/", "categories": "HTML", "tags": "前端", "date": "2022-08-28 02:00:00 +0000", "snippet": "HTML网页编程语言概念\t就是说这个语言是用来开发网页的，而且写完代码后不用编译，直接用浏览器打开就能渲染出代码效果。专业点说HTML是超文本标记语言，现在流行的版本是HTML5. HTML网页编程语言在前端网页开发的江湖地位挺高，与CSS，JavaScript并称前端三剑客。常用标签基本标签&lt;html&gt;...&lt;/html&gt; \t定义 HTML 文档&lt;head&gt;...&lt;/head&gt; \t文档的信息&lt;meta&gt; HTML 文档的元信息&lt;title&gt;...&lt;/title&gt; 文档的标题&lt;link&gt; 文档与外部资源的关系&lt;style&gt;...&lt;/style&gt; \t文档的样式信息&lt;body&gt;...&lt;/body&gt; \t\t可见的页面内容&lt;!--...--&gt; 注释 文本标签&lt;h1&gt;...&lt;/h1&gt; 标题字大小（h1~h6）&lt;b&gt;...&lt;/b&gt; 粗体字&lt;strong&gt;...&lt;/strong&gt; 粗体字(强调) &lt;i&gt;...&lt;/i&gt; 斜体字 &lt;em&gt;...&lt;/em&gt; 斜体字(强调)&lt;center&gt;...&lt;/center&gt; 居中文本&lt;ul&gt;...&lt;/ul&gt; 无序列表 &lt;ol&gt;...&lt;/ol&gt; 有序列表&lt;li&gt;...&lt;/li&gt; 列表项目&lt;a href=\"...\"&gt;...&lt;/a&gt; 超链接&lt;font&gt; 定义文本字体尺寸、颜色、大小&lt;sub&gt; 下标&lt;sup&gt; 上标&lt;br&gt; 换行&lt;p&gt; 段落&lt;p&gt;...&lt;/p&gt; \t\t\t\t换段&lt;hr /&gt;\t\t\t\t\t⽔水平分割线&lt;dl&gt;...&lt;/dl&gt;\t\t\t自定义列表&lt;dt&gt;...&lt;/dt&gt;\t\t\t自定义列表头&lt;dd&gt;...&lt;/dd&gt;\t\t\t自定义列表内容&lt;div&gt;...&lt;/div&gt; \t\t\t用于组合块级元素，以便通过CSS来对这些元素进行格式化&lt;span&gt;...&lt;/span&gt; \t\t用于包含的文本，可用CSS对它定义样式或用JavaScript对它进行操作。 图形标签&lt;img src=’\"...\"&gt; \t\t定义图像&lt;hr&gt; \t水平线 表格标签&lt;table&gt;...&lt;/table&gt; \t定义表格&lt;th&gt;...&lt;/th&gt; 定义表格中的表头单元格&lt;tr&gt;...&lt;/tr&gt; 定义表格中的行&lt;td&gt;...&lt;/td&gt; \t定义表格中的单元 其它标签&lt;form&gt;...&lt;/form&gt; \t定义供用户输入的 HTML 表单&lt;frame&gt; 定义框架集的窗口或框架再多就往这看https://www.runoob.com/html/html-tutorial.html" }, { "title": "CSS", "url": "/posts/CSS/", "categories": "CSS", "tags": "前端", "date": "2022-08-28 02:00:00 +0000", "snippet": "CSS网页编程语言概念\t就是说这个语言也是用来开发网页的，但不完全开发，它属于是控制网页 内容 表现的语言。 往往跟HTML混合使用，与HTML，JavaScript并称前端三剑客。常用元素属性字体属性font-family\t\t\t字体类型\tfont-size\t\t\t字体大小\tfont-weight\t\t\t字体粗细\tfont-style\t\t\t文本样式\tcolor\t\t\t\t字体颜色\t 文本属性center\t\t\t\t居中对齐left\t\t\t\t左对齐right\t\t\t\t右对齐underline\t\t\t下划线 （常用）none\t\t\t\t可以给 a 标签去掉下划线overline\t\t\t上划线（不常用）line-through\t\t删除线 （不常用） 背景属性repeat\t\t\t\t平铺no-repeat\t\t\t不平铺repeat-x\t\t\t水平平铺repeat-y\t\t\t垂直平铺再多就往这看https://www.runoob.com/css/css-tutorial.html" }, { "title": "Hello World", "url": "/posts/Hello-world/", "categories": "Java", "tags": "后端", "date": "2022-08-25 02:34:00 +0000", "snippet": "属于你的第一个Java程序操作步骤①右击电脑桌面创建一个的文本文件②把文件的名字修改为”Test.java”③用记事本打开这个文件,在文件中书写下面的代码.public class Test{ public static void main(String[] args){ System.out.println(\"Hello World\"); }}解释public: 用来限制\"类名\"和\"文件名\"必须保持一致.class Test: 表示定义一个类,类名叫\"Test\".public static void main(String[] args): 这叫main方法,也叫主方法，是java程序的入口.程序就是从这开始运行的.System.out.println(\"Hello World\");输出语句,将(\" \")里面的内容Hello World在控制台（DOS窗口）打印出来.运行该程序④在Dos窗口中找到该文件（不会用DOS命令的话返回首页找DOS博文）⑤编译并运行打开DOS黑窗口输入：cd Desktop再输入：javac Test.java又输入：java Test解释cd Desktop这句代码表示:我们告诉电脑：“兄弟，把路径给我转到桌面上，我待会要操作桌面上的文件。”javac Test.java这句代码表示:我们告诉电脑：“兄弟，你帮我把Test.java这个文件编译一下，我一会要运行它。” 然后电脑就会把Test.java这个文件编译一下，编译成功后会在桌面生成一个Test.class文件。java Test:我们告诉电脑：“好兄弟，你现在再帮我运行一下Test文件，把内容给我放出来看看。”常见问题1).XXX不存在/找不到符号: 英文单词写错了(大小写字母也算)2).已到达文件结尾: {}没有成对出现. 要么多了,要么少了3).需要\")\": ()没有成对出现. 要么多了,要么少了\t\t4).非法字符XXX: 标点符号写成中文的标点符号了.5).类XXX是公共的,应在名为XXX的文件中声明:\t类名和文件名不一样6).找不到文件XXX: cmd运行的路径错误/文件名写错了7).XXX不是内部或外部命令: 环境变量配置的有问题/因为操作系统的问题导致环境变量失效了8).编码XXX不可映射的字符: 编码设置错误(NotePad++没有配置)9).需要class,interface或enum: 多个一个大括号}" }, { "title": "JDK安装", "url": "/posts/JDK/", "categories": "Java", "tags": "后端", "date": "2022-08-25 02:00:00 +0000", "snippet": "配置电脑Java运行环境安装JDK过程略..." }, { "title": "DOS", "url": "/posts/DOS/", "categories": "Java", "tags": "后端", "date": "2022-08-25 02:00:00 +0000", "snippet": "常用DOS命令打开DOS窗口概述: DOS窗口,又称之为\"命令行窗口,控制台\".打开:\t1.常规方式\t\t1.1:按下 Windows + R 按键\t\t1.2:在运行界面中,输入cmd,点击回车\t\t1.3:再通过DOS命令,找到对应的文件夹.\t2.快捷方式(推荐)\t\t2.1:打开指定文件夹.\t\t2.2:在\"路径栏\"中,直接输入cmd,然后点击回车按第一种方式的话就直接快捷键Windows + R唤醒运行框，在里面输入cmd敲回车就成了。DOS窗口就长这样常用DOS命令盘符: -&gt; 切换到对应的盘符cd 文件夹 -&gt; 打开指定文件夹cd / -&gt; 回到盘符根目录cd .. -&gt; 回到上级文件夹dir -&gt; 显示当前文件夹中的所有内容cls -&gt; 清屏exit -&gt; 退出" }, { "title": "Java概述", "url": "/posts/JavaSE-1/", "categories": "Java", "tags": "后端", "date": "2022-08-25 01:30:00 +0000", "snippet": "Java概述Java语言Java语言：是一个用于人和计算机进行交互交流的语言技术发明者是 詹姆斯·高斯林Java分支JavaSE：java标准版其实就是java基础，又叫做J2SE。 JavaME：Java小型版主要用于嵌入式开发，但现在已经被Android替代又叫做J2ME。 JAvaEE：Java版就是网站开发又叫做J2EE。Java优势开源：指开源代码，用java编写的程序底层是怎么运行的大家都能看到，相当于同类编程语言玩家斗地主java明牌了属于是。 跨平台：指java程序不需要做任何处理，就能在各种操作系统上运行。一般情况下每个操作系统的程序都各不互通，但java程序却能他们之间自如游走，强悍如斯。Java跨平台原理java：依赖于jvm虚拟机实现跨平台。JDK，JRE，JVM的关系JDK：丫说白了就是个大的工具包,包里有 JDK + JRE + JDK工具。 JRE：负责运行java程序，包含 JVM + java类库 \tJVM：虚拟机，给java程序创建一个可运行的环境。Java基本语法注释概述: 就是对代码进行\"解释说明\"的文字.格式:\t单行注释: // 注释内容\t多行注释: /* 注释内容 */\t文档注释: /** 注释内容 */关键字概念: 在Java中\"被赋予特定含义\"的单词.特点:\t1.全小写\t2.会变色字面值常量概述: 字面量又叫做\"字面值常量\"分类:\t字符串: 被双引号包括起来\"abc\",\"我爱Java\"\t字符: 被单引号包括起来的一个字或符号. 'a','5','我'\t整数: 1,3,5,-9,-13\t浮点: 1.3,5.4,-2.2\t布尔: true,false\t空: null,表示什么都没有数据类型概述: 其实就是java中数据的类型,可以理解为是英文写法分类:\t基本数据类型:\t\t整数: byte,short,int,long\t\t浮点: float,double\t\t字符: char\t\t布尔: boolean\t引用数据类型:\t\t字符串: String标识符命名规则概述: 标识符其实就是\"给类或变量起的名字\".规范:\t硬规则:\t\t1.必须由\"数字,字母,下划线(_),美元符($)\"组成.\t\t2.不能以数字作为开头.\t\t3.不能是关键字.\t\t4.区分大小写.\t潜规则:\t\t1.见名知意.\t\t2.给\"变量/方法\"起名字的时候,要使用\"小驼峰命名法\".\t\t3.给\"类/接口\"起名字的时候,要使用\"大驼峰命名法\".扩展:\t小驼峰命名法: 第1个单词全小写,其他单词首字母大写,其他字母小写. student, studentName, studentAgeName\t大驼峰命名法: 所有单词,首字母大写,其他字母小写. Student, StudentName, StudentAgeName变量概念变量: 其实就是内存中的一块空间.变量名: 给空间起的名字就是\"变量名\".数据值: 空间中存储的数据.数据类型: 对空间中存储的数据的限制.格式格式:\t数据类型 变量名 = 数据值;解析:\t该格式本质上是两句话. 数据类型 变量名: 叫做变量的定义.本质上是去内存中\"挖一块空间\" 变量名 = 数据值: 叫做变量的赋值,其实就是给\"空间装数据\"注意点1.变量名不能重复. 2.Java以分号作为一句话的结尾. 一句话可以定义多个变量. (不建议)3.变量在使用之前必须赋值.4.定义long类型变量时,数值后边必须加L.5.定义float类型变量时,数值后边必须加F.6.变量只能在他所在的大括号中使用.xxxxxxxxxx a1.变量名不能重复.    2.Java以分号作为一句话的结尾. 一句话可以定义多个变量. (不建议)3.变量在使用之前必须赋值.4.定义long类型变量时,数值后边必须加L.5.定义float类型变量时,数值后边必须加F.6.变量只能在他所在的大括号中使用." } ]
